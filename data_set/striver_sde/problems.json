[
    {
        "problem_title": "Set Matrix Zero",
        "problem_statement": "Given a matrix if an element in the matrix is 0 then you will have to set its entire column and row to 0 and then return the matrix.",
        "difficulty": "Medium",
        "topic": "Arrays, Hashing, Matrix",
        "better_approach": "In the previous approach, we were marking the row and column with -1 while traversing the matrix. Here we will reduce the time complexity by marking the cells after the traversal. Approach (Using two extra arrays): First, we will declare two arrays: a row array of size N and a col array of size M and both are initialized with 0. Then, we will use two loops (nested loops) to traverse all the cells of the matrix. If any cell (i, j) contains the value 0, we will mark ith index of row array row[i] and jth index of col array col[j] as 1. It signifies that all the elements in the ith row and jth column will be 0 in the final matrix. We will perform this for every cell containing 0. Finally, we will again traverse the entire matrix and put 0 into all the cells (i, j) for which either row[i] or col[j] is marked as 1. Thus we will get our final matrix. Intuition: Instead of marking -1 while traversing, we mark indices in separate row and column arrays and later zero them out. This avoids unnecessary modifications mid-traversal.",
        "brute_force_explanation": "Approach: First, we will use two nested loops to traverse all the cells of the matrix. If any cell (i, j) contains the value 0, we will mark all cells in row i and column j with -1 except those which contain 0. We will perform this for every cell containing 0. Finally, we will mark all cells containing -1 with 0. Thus the given matrix will be modified according to the question. Intuition: We mark -1 instead of 0 during traversal to avoid modifying the matrix prematurely and losing track of original zeros.",
        "optimized_explanation": "We can optimize the space complexity by using the first row and first column of the given matrix to keep track of which cells need to be marked 0. We handle overlap at matrix[0][0] with an extra variable col0. If any cell in the 0th row contains 0, mark matrix[0][0] = 0; if any cell in the 0th column contains 0, set col0 = 0. After traversing, modify all cells (1,1) to (n-1,m-1) based on these flags. Then, update the first row and column separately based on matrix[0][0] and col0. This reduces space complexity to O(1).",
        "key_idea": "Reduce auxiliary space from O(N+M) to O(1) by using matrix's own first row and column as markers.",
        "code_brute_force": "function markRow(matrix, n, m, i) { for (let j = 0; j < m; j++) { if (matrix[i][j] !== 0) { matrix[i][j] = -1; } } } function markCol(matrix, n, m, j) { for (let i = 0; i < n; i++) { if (matrix[i][j] !== 0) { matrix[i][j] = -1; } } } function zeroMatrix(matrix, n, m) { for (let i = 0; i < n; i++) { for (let j = 0; j < m; j++) { if (matrix[i][j] === 0) { markRow(matrix, n, m, i); markCol(matrix, n, m, j); } } } for (let i = 0; i < n; i++) { for (let j = 0; j < m; j++) { if (matrix[i][j] === -1) { matrix[i][j] = 0; } } } return matrix; }",
        "code_optimized": "function setZeroes(matrix) { const n = matrix.length; const m = matrix[0].length; let col0 = 1; for (let i = 0; i < n; i++) { if (matrix[i][0] === 0) col0 = 0; for (let j = 1; j < m; j++) { if (matrix[i][j] === 0) matrix[i][0] = matrix[0][j] = 0; } } for (let i = n - 1; i >= 0; i--) { for (let j = m - 1; j >= 1; j--) { if (matrix[i][0] === 0 || matrix[0][j] === 0) matrix[i][j] = 0; } if (col0 === 0) matrix[i][0] = 0; } return matrix; }"
    }
]