[
    {
        "problem_title": "Set Matrix Zero",
        "problem_statement": "Given a matrix if an element in the matrix is 0 then you will have to set its entire column and row to 0 and then return the matrix.",
        "difficulty": "Medium",
        "topic": "Arrays, Hashing, Matrix",
        "better_approach": "In the previous approach, we were marking the row and column with -1 while traversing the matrix. Here we will reduce the time complexity by marking the cells after the traversal. Approach (Using two extra arrays): First, we will declare two arrays: a row array of size N and a col array of size M and both are initialized with 0. Then, we will use two loops (nested loops) to traverse all the cells of the matrix. If any cell (i, j) contains the value 0, we will mark ith index of row array row[i] and jth index of col array col[j] as 1. It signifies that all the elements in the ith row and jth column will be 0 in the final matrix. We will perform this for every cell containing 0. Finally, we will again traverse the entire matrix and put 0 into all the cells (i, j) for which either row[i] or col[j] is marked as 1. Thus we will get our final matrix. Intuition: Instead of marking -1 while traversing, we mark indices in separate row and column arrays and later zero them out. This avoids unnecessary modifications mid-traversal.",
        "brute_force_explanation": "Approach: First, we will use two nested loops to traverse all the cells of the matrix. If any cell (i, j) contains the value 0, we will mark all cells in row i and column j with -1 except those which contain 0. We will perform this for every cell containing 0. Finally, we will mark all cells containing -1 with 0. Thus the given matrix will be modified according to the question. Intuition: We mark -1 instead of 0 during traversal to avoid modifying the matrix prematurely and losing track of original zeros.",
        "optimized_explanation": "We can optimize the space complexity by using the first row and first column of the given matrix to keep track of which cells need to be marked 0. We handle overlap at matrix[0][0] with an extra variable col0. If any cell in the 0th row contains 0, mark matrix[0][0] = 0; if any cell in the 0th column contains 0, set col0 = 0. After traversing, modify all cells (1,1) to (n-1,m-1) based on these flags. Then, update the first row and column separately based on matrix[0][0] and col0. This reduces space complexity to O(1).",
        "key_idea": "Reduce auxiliary space from O(N+M) to O(1) by using matrix's own first row and column as markers.",
        "code_brute_force": "function markRow(matrix, n, m, i) { for (let j = 0; j < m; j++) { if (matrix[i][j] !== 0) { matrix[i][j] = -1; } } } function markCol(matrix, n, m, j) { for (let i = 0; i < n; i++) { if (matrix[i][j] !== 0) { matrix[i][j] = -1; } } } function zeroMatrix(matrix, n, m) { for (let i = 0; i < n; i++) { for (let j = 0; j < m; j++) { if (matrix[i][j] === 0) { markRow(matrix, n, m, i); markCol(matrix, n, m, j); } } } for (let i = 0; i < n; i++) { for (let j = 0; j < m; j++) { if (matrix[i][j] === -1) { matrix[i][j] = 0; } } } return matrix; }",
        "code_optimized": "function setZeroes(matrix) { const n = matrix.length; const m = matrix[0].length; let col0 = 1; for (let i = 0; i < n; i++) { if (matrix[i][0] === 0) col0 = 0; for (let j = 1; j < m; j++) { if (matrix[i][j] === 0) matrix[i][0] = matrix[0][j] = 0; } } for (let i = n - 1; i >= 0; i--) { for (let j = m - 1; j >= 1; j--) { if (matrix[i][0] === 0 || matrix[0][j] === 0) matrix[i][j] = 0; } if (col0 === 0) matrix[i][0] = 0; } return matrix; }"
    },
    {
        "problem_title": "Program to generate Pascal's Triangle",
        "problem_statement": "Write a program to generate Pascal's triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown in the figure below:",
        "difficulty": "Easy",
        "topic": "",
        "brute_force_explanation": "To generate the entire Pascal’s Triangle for the first N rows, we can start with the first row containing a single 1 and iteratively build each subsequent row using the property that every element (except the first and last) is the sum of the two elements directly above it from the previous row. The first and last elements of each row are always 1. By storing the previous row, we can calculate the next row easily. This process continues until we have constructed all N rows, resulting in the complete Pascal’s Triangle structure.",
        "better_approach": "To print the Nth row of the pascal triangle we can take advantage of the relationship between Nth element and binomial coefficients. In a pascal's triangle, the Nth row contains the binomial coefficients C(N-1, 0), C(N-1, 1) and so on till C(N-1, N-1). Thus we can simply calculate all these values to return the Nth row of pascal triangle. Instead of computing full factorials, we can start with the first value as 1, and use the relation C(n, k) = C(n, k−1) × (n−k+1) / k to compute the next value from the previous one in constant time.",
        "optimized_explanation": "To find the element at the coordinates (R,C) where R is the row number and C is the Column number, we can simply simulate the generation of pascal's triangle for R rows. In Pascal’s Triangle, the element at row R and column C corresponds to the binomial coefficient (r-1)C(c-1). To calculate this binomial coefficient, we can simply apply the formula of binomial coefficient i.e. (r-1)!/(c-1)!(r-c)!. Instead of computing full factorials (which can overflow and be slow), we can multiply and divide in a loop to compute the coefficient efficiently.",
        "key_idea": "",
        "code_brute_force": "class Solution {\n    // Function to generate Pascal's Triangle up to numRows\n    generate(numRows) {\n        let triangle = [];\n        for (let i = 0; i < numRows; i++) {\n            let row = new Array(i + 1).fill(1);\n            for (let j = 1; j < i; j++) {\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\n            }\n            triangle.push(row);\n        }\n        return triangle;\n    }\n}\nlet obj = new Solution();\nlet n = 5;\nlet result = obj.generate(n);\nresult.forEach(row => console.log(row.join(\" \")));",
        "code_better_approach": "class Solution {\n    getNthRow(N) {\n        let row = [];\n        let val = 1;\n        row.push(val);\n        for (let k = 1; k < N; k++) {\n            val = val * (N - k) / k;\n            row.push(val);\n        }\n        return row;\n    }\n}\nlet N = 5;\nlet sol = new Solution();\nlet result = sol.getNthRow(N);\nconsole.log(result.join(\" \"));",
        "code_optimized": "class Solution {\n    findPascalElement(r, c) {\n        let n = r - 1;\n        let k = c - 1;\n        let result = 1;\n        for (let i = 0; i < k; i++) {\n            result *= (n - i);\n            result /= (i + 1);\n        }\n        return result;\n    }\n}\nconst sol = new Solution();\nlet r = 5, c = 3;\nconsole.log(sol.findPascalElement(r, c));"
    },
    {
        "problem_title": "next_permutation : find next lexicographically greater permutation",
        "problem_statement": "Given an array Arr[] of integers, rearrange the numbers of the given array into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange to the lowest possible order (i.e., sorted in ascending order).",
        "difficulty": "Medium",
        "topic": "Arrays, Permutations",
        "brute_force_explanation": "The brute force approach to find the next permutation is to find all possible permutations of the array and then look for next permutation. Find all possible permutations of elements present and store them. Sort the permutations and search input from all possible permutations. Print the next permutation present right after it. If the current permutation is the last, return the first permutation in the list.",
        "better_approach": null,
        "optimized_explanation": "We want to rearrange the array to form the next greater permutation. If that's not possible (i.e., it's the last permutation), we return the smallest one (i.e., sorted ascendingly). To find this next permutation with minimal change, we need to find a digit that can be increased slightly to make the number bigger and then rearrange the remaining part to be the smallest possible. Traverse from the end and find the first index where the current digit is smaller than the next one (this is the 'breaking point'). Then again traverse from the end to find the first digit greater than the breaking point digit and swap them. Finally, reverse the part of the array to the right of the breaking point to get the smallest next permutation. If no such breaking point exists (entire array is descending), just reverse the whole array.",
        "key_idea": "Find the first decreasing element from the end, swap it with the next larger element to its right, and reverse the remaining suffix to get the next lexicographically greater permutation.",
        "code_brute_force": "class Solution {\n    // Helper to generate all permutations\n    permute(nums) {\n        const res = [];\n        const backtrack = (start) => {\n            if (start === nums.length) {\n                res.push([...nums]);\n                return;\n            }\n            for (let i = start; i < nums.length; i++) {\n                [nums[i], nums[start]] = [nums[start], nums[i]];\n                backtrack(start + 1);\n                [nums[i], nums[start]] = [nums[start], nums[i]];\n            }\n        };\n        nums.sort((a, b) => a - b);\n        backtrack(0);\n        return res;\n    }\n\n    // Main function to get next permutation\n    nextPermutation(nums) {\n        const perms = this.permute([...nums]);\n\n        for (let i = 0; i < perms.length; i++) {\n            let equal = true;\n            for (let j = 0; j < nums.length; j++) {\n                if (perms[i][j] !== nums[j]) {\n                    equal = false;\n                    break;\n                }\n            }\n            if (equal) {\n                if (i === perms.length - 1)\n                    return perms[0];\n                return perms[i + 1];\n            }\n        }\n        return nums;\n    }\n}\n\n// Driver\nconst sol = new Solution();\nlet nums = [1, 2, 3];\nlet result = sol.nextPermutation(nums);\nconsole.log(result.join(\" \"));",
        "code_better_approach": null,
        "code_optimized": "class Solution {\n    // Function to find next permutation\n    nextPermutation(nums) {\n        let index = -1;\n        for (let i = nums.length - 2; i >= 0; i--) {\n            if (nums[i] < nums[i + 1]) {\n                index = i;\n                break;\n            }\n        }\n        if (index === -1) {\n            nums.reverse();\n            return;\n        }\n        for (let i = nums.length - 1; i > index; i--) {\n            if (nums[i] > nums[index]) {\n                [nums[i], nums[index]] = [nums[index], nums[i]];\n                break;\n            }\n        }\n        let left = index + 1, right = nums.length - 1;\n        while (left < right) {\n            [nums[left], nums[right]] = [nums[right], nums[left]];\n            left++;\n            right--;\n        }\n    }\n}\n\nfunction main() {\n    let nums = [1, 2, 3];\n    const sol = new Solution();\n    sol.nextPermutation(nums);\n    console.log(nums.join(\" \"));\n}\n\nmain();"
    },
    {
        "problem_title": "Kadane's Algorithm : Maximum Subarray Sum in an Array",
        "problem_statement": "Given an integer array arr, find the contiguous subarray (containing at least one number) which has the largest sum and returns its sum and prints the subarray.",
        "difficulty": "Medium",
        "topic": "Arrays, Dynamic Programming",
        "brute_force_explanation": "We will check the sum of every possible subarray and consider the maximum among them. To get every possible subarray sum, we will be using three nested loops. The first loops(say i and j) will iterate over every possible starting index and ending index of a subarray. Basically, in each iteration, the subarray range will be from index i to index j. Using another loop we will get the sum of the elements of the subarray [i…..j]. Among all values of the sum calculated, we will consider the maximum one.",
        "better_approach": "If we carefully observe, we can notice that to get the sum of the current subarray we just need to add the current element(i.e. arr[j]) to the sum of the previous subarray i.e. arr[i….j-1]. This way, we can remove the third loop and calculate the sum in two nested loops, maintaining the current sum and updating the maximum sum accordingly.",
        "optimized_explanation": "The intuition of Kadane’s Algorithm is not to consider any subarray with a sum less than 0, as it will reduce the total. We iterate once through the array, maintaining a running sum. If the sum becomes negative, we reset it to 0. The maximum value seen during this process is the answer. This allows us to find the maximum subarray sum in linear time.",
        "key_idea": "Ignore negative cumulative sums because they cannot contribute to a maximum subarray; keep track of the highest running sum seen so far while resetting the current sum when it drops below zero.",
        "code_brute_force": "function maxSubarraySum(arr, n) {\n    let maxi = Number.MIN_SAFE_INTEGER; // maximum sum\n\n    for (let i = 0; i < n; i++) {\n        for (let j = i; j < n; j++) {\n            let sum = 0;\n            for (let k = i; k <= j; k++) {\n                sum += arr[k];\n            }\n            maxi = Math.max(maxi, sum);\n        }\n    }\n\n    return maxi;\n}\n\nconst arr = [ -2, 1, -3, 4, -1, 2, 1, -5, 4];\nconst n = arr.length;\nconst maxSum = maxSubarraySum(arr, n);\nconsole.log(`The maximum subarray sum is: ${maxSum}`);",
        "code_better_approach": "function maxSubarraySum(arr, n) {\n    let maxi = Number.MIN_SAFE_INTEGER; // maximum sum\n\n    for (let i = 0; i < n; i++) {\n        let sum = 0;\n        for (let j = i; j < n; j++) {\n            sum += arr[j];\n            maxi = Math.max(maxi, sum);\n        }\n    }\n\n    return maxi;\n}\n\nlet arr = [ -2, 1, -3, 4, -1, 2, 1, -5, 4];\nlet n = arr.length;\nlet maxSum = maxSubarraySum(arr, n);\nconsole.log(\"The maximum subarray sum is: \" + maxSum);",
        "code_optimized": "function maxSubarraySum(arr, n) {\n    let maxi = Number.MIN_SAFE_INTEGER; // maximum sum\n    let sum = 0;\n\n    for (let i = 0; i < n; i++) {\n        sum += arr[i];\n\n        if (sum > maxi) {\n            maxi = sum;\n        }\n\n        if (sum < 0) {\n            sum = 0;\n        }\n    }\n\n    return maxi;\n}\n\nconst arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4];\nconst n = arr.length;\nconst maxSum = maxSubarraySum(arr, n);\nconsole.log(\"The maximum subarray sum is: \" + maxSum);"
    },
    {
        "problem_title": "Sort an array of 0s, 1s and 2s",
        "problem_statement": "Given an array consisting of only 0s, 1s, and 2s. Write a program to in-place sort the array without using inbuilt sort functions. (Expected: Single pass-O(N) and constant space)",
        "difficulty": "Medium",
        "topic": "Arrays, Two Pointers, Sorting",
        "brute_force_explanation": "Sorting (even if it is not the expected solution here but it can be considered as one of the approaches). Since the array contains only 3 integers, 0, 1, and 2. Simply sorting the array would arrange the elements in increasing order.",
        "better_approach": "Since there are only 3 distinct values, we can count the occurrences of 0, 1, and 2, and then overwrite the array based on these counts. This approach requires two passes: one for counting and one for rewriting the array.",
        "optimized_explanation": "This problem is a variation of the Dutch National Flag algorithm. It uses three pointers: low, mid, and high. The array is divided into three parts — [0..low-1] contains 0s, [low..mid-1] contains 1s, and [high+1..n-1] contains 2s. We process the array as follows: if arr[mid] == 0, swap arr[low] and arr[mid] and move both forward; if arr[mid] == 1, move mid forward; if arr[mid] == 2, swap arr[mid] and arr[high] and move high backward. This ensures all 0s, 1s, and 2s are sorted in one pass.",
        "key_idea": "Partition the array into three regions using low, mid, and high pointers to group 0s, 1s, and 2s respectively, following the Dutch National Flag algorithm.",
        "code_brute_force": "function sortArray(arr) {\n    return arr.sort((a, b) => a - b);\n}\n\nlet arr = [0, 2, 1, 2, 0, 1];\nconsole.log('After sorting:', sortArray(arr));",
        "code_better_approach": "function sortArray(arr) {\n    let count0 = 0, count1 = 0, count2 = 0;\n\n    for (let num of arr) {\n        if (num === 0) count0++;\n        else if (num === 1) count1++;\n        else count2++;\n    }\n\n    let i = 0;\n    while (count0--) arr[i++] = 0;\n    while (count1--) arr[i++] = 1;\n    while (count2--) arr[i++] = 2;\n\n    return arr;\n}\n\nlet arr = [0, 2, 1, 2, 0, 1];\nconsole.log('After sorting:', sortArray(arr));",
        "code_optimized": "function sortArray(arr) {\n    let low = 0, mid = 0, high = arr.length - 1;\n\n    while (mid <= high) {\n        if (arr[mid] === 0) {\n            [arr[low], arr[mid]] = [arr[mid], arr[low]];\n            low++;\n            mid++;\n        } else if (arr[mid] === 1) {\n            mid++;\n        } else {\n            [arr[mid], arr[high]] = [arr[high], arr[mid]];\n            high--;\n        }\n    }\n\n    return arr;\n}\n\nlet arr = [0, 2, 1, 2, 0, 1];\nconsole.log('After sorting:', sortArray(arr));"
    },
    {
        "problem_title": "Stock Buy And Sell",
        "problem_statement": "You are given an array of prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
        "difficulty": "Easy",
        "topic": "Arrays, Dynamic Programming, Greedy",
        "brute_force_explanation": "We can simply use two loops and track every possible pair of buy and sell days. For each pair (i, j) where j > i, compute the profit as prices[j] - prices[i], and keep track of the maximum profit found. This checks all possible transactions but is inefficient for large arrays.",
        "better_approach": null,
        "optimized_explanation": "We can achieve O(N) time by maintaining the minimum price seen so far while traversing the array. At each step, compute the potential profit by subtracting the minimum price from the current day's price. Update the maximum profit if this value is higher. If a new lower price is found, update the minimum price. This ensures we always buy at the lowest point before the current day and sell at the highest point after.",
        "key_idea": "Keep track of the minimum stock price encountered so far and compute the profit at each step to find the maximum possible profit in one pass.",
        "code_brute_force": "function maxProfit(prices) {\n    let maxPro = 0;\n    for (let i = 0; i < prices.length; i++) {\n        for (let j = i + 1; j < prices.length; j++) {\n            if (prices[j] > prices[i]) {\n                maxPro = Math.max(maxPro, prices[j] - prices[i]);\n            }\n        }\n    }\n    return maxPro;\n}\n\nconst prices = [7, 1, 5, 3, 6, 4];\nconsole.log('Max profit is:', maxProfit(prices));",
        "code_better_approach": null,
        "code_optimized": "function maxProfit(prices) {\n    let maxPro = 0;\n    let minPrice = Infinity;\n\n    for (let price of prices) {\n        if (price < minPrice) {\n            minPrice = price;\n        } else {\n            maxPro = Math.max(maxPro, price - minPrice);\n        }\n    }\n\n    return maxPro;\n}\n\nconst prices = [7, 1, 5, 3, 6, 4];\nconsole.log('Max profit is:', maxProfit(prices));"
    }
]